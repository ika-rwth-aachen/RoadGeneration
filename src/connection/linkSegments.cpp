#ifndef LINK_SEGMENT
#define LINK_SEGMENT

/**
 * @file linkSegments.cpp
 *
 * @brief file contains methodology for linking two segments 
 *
 * @author Christian Geller
 * Contact: christian.geller@rwth-aachen.de
 *
 */

#include "roadNetwork.h"
#include "curve.h"

/**
 * @brief function links all specified segments 
 *  	the reference frame has to be specified
 * 		two segments can be linked by determine two contactpoints of the roads 
 * 
 * @param doc 	tree structure which contains the input data
 * @param data 	roadNetwork structure generated by the tool
 * @return int 	error code
 */
int RoadNetwork::linkSegments(pugi::xml_document &doc)
{
	RoadNetwork& data = *this;
	std::cout << "Processing linkSegments" << std::endl;

	pugi::xml_node links = doc.child("roadNetwork").child("links");

	if (!links)
	{
		std::cerr << "ERR: 'links' are not specified in input file." << std::endl;
		std::cerr << "\t -> skip segment linking" << std::endl;
		return 0;
	}

	// define reference system
	int refId = links.attribute("refId").as_int();
	double hdgOffset = links.attribute("hdgOffset").as_double();
	double xOffset = links.attribute("xOffset").as_double();
	double yOffset = links.attribute("yOffset").as_double();

	for (auto &&r : data.getRoads())
	{
		if (r.getJunction() != refId)
			continue;

		for (auto &&g : r.getGeometries())
		{

			// transform geometries of reference segement into reference system
			double x = g.x * cos(hdgOffset) - g.y * sin(hdgOffset);
			double y = g.x * sin(hdgOffset) + g.y * cos(hdgOffset);

			g.x = x + xOffset;
			g.y = y + yOffset;
			g.hdg = g.hdg + hdgOffset;
		}
	}

	// --- add other specified segments ----------------------------------------
	for (pugi::xml_node segmentLink : links.children("segmentLink"))
	{
		// get properties
		int fromSegment = segmentLink.attribute("fromSegment").as_int();
		int toSegment = segmentLink.attribute("toSegment").as_int();
		int fromRoadId = segmentLink.attribute("fromRoad").as_int();
		int toRoadId = segmentLink.attribute("toRoad").as_int();
		std::string fromPos = (std::string)segmentLink.attribute("fromPos").value();
		std::string toPos = (std::string)segmentLink.attribute("toPos").value();
		Road fromRoad;
		Road toRoad;

		// assumption is that "fromSegement" is already linked to reference frame

		double fromX, fromY, fromHdg;
		double toX, toY, toHdg;

		// check if fromSegment is junction
		bool fromIsJunction = false;
		for (auto &&j : data.getJunctions())
			if (j.id == fromSegment)
				fromIsJunction = true;

		// check if toSegment is junction
		bool toIsJunction = false;
		for (auto &&j : data.getJunctions())
			if (j.id == toSegment)
				toIsJunction = true;

		// save from position
		for (auto &&r : data.getRoads())
		{
			if (r.getJunction() != fromSegment || r.getInputID() != fromRoadId)
				continue;
			if (fromIsJunction && r.getInputPos() != fromPos)
				continue;

			fromRoad = r;
			fromRoadId = r.getID();

			// if junction, the contact point is always at "end" of a road
			if (fromIsJunction)
				fromPos = "end";

			if (fromPos == "start")
			{
				fromX = r.getGeometries().front().x;
				fromY = r.getGeometries().front().y;
				fromHdg = r.getGeometries().front().hdg;
			}
			else if (fromPos == "end")
			{
				geometry g = r.getGeometries().back();
				curve(g.length, g, g.x, g.y, g.hdg, 1);
				fromX = g.x;
				fromY = g.y;
				fromHdg = g.hdg;
			}
		}

		// save to position
		for (auto &&r : data.getRoads())
		{
			if (r.getJunction() != toSegment || r.getInputID() != toRoadId)
				continue;
			if (toIsJunction && r.getInputPos() != toPos)
				continue;

			toRoad = r;
			toRoadId = r.getID();

			// if junction, the contact point is always at "end" of a road
			if (toIsJunction)
				toPos = "end";

			if (toPos == "start")
			{
				toX = r.getGeometries().front().x;
				toY = r.getGeometries().front().y;
				toHdg = r.getGeometries().front().hdg;
			}
			else if (toPos == "end")
			{
				geometry g = r.getGeometries().back();
				toX = g.x;
				toY = g.y;
				toHdg = g.hdg;
				curve(g.length, g, toX, toY, toHdg, 1);
			}
		}

		// --- rotate and shift current road according to from position --------
		double dx, dy;

		// compute hdgOffset between the two segments
		double dPhi = fromHdg - toHdg + M_PI;
		if (fromPos == "start")
			dPhi += M_PI;
		if (toPos == "start")
			dPhi += M_PI;
		fixAngle(dPhi);

		// if toPos is end, the actual toPos has to be computed
		if (toPos == "end")
		{
			geometry g = toRoad.getGeometries().back();
			toX = g.x * cos(dPhi) - g.y * sin(dPhi);
			toY = g.x * sin(dPhi) + g.y * cos(dPhi);
			toHdg = g.hdg + dPhi;
			curve(g.length, g, toX, toY, toHdg, 1);
		}

		// compute x / y offset between the two segments
		dx = fromX - toX;
		dy = fromY - toY;

		// shift all geometries which belong to the toSegment according two the offsets determined above
		for (auto &&r : data.getRoads())
		{
			if (r.getJunction() != toSegment)
				continue;

			for (auto &&g : r.getGeometries())
			{
				double x = g.x * cos(dPhi) - g.y * sin(dPhi);
				double y = g.x * sin(dPhi) + g.y * cos(dPhi);

				g.x = x + dx;
				g.y = y + dy;
				g.hdg = g.hdg + dPhi;
				fixAngle(g.hdg);
			}
		}

		// update predecessor and successor
		for (auto &&r : data.getRoads())
		{
			if (r.getID() == toRoadId)
				r.getPredecessor().id = fromRoadId;
			if (r.getID() == fromRoadId)
				r.getSucessor().id = toRoadId;
		}
	}
	return 0;
}

#endif